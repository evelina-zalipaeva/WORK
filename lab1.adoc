:diagram-use-plantuml:
:author: Залипаева Эвелина КЭ-201
:icon: front
:secttrue: true
:toc: left
:toclevels: 2
:secttruelevels: 2
:sectnums: |,all|
:stylesheet: custom.css
:stylesdir: ./styles
:imagesdir: pic
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица

include::test.adoc[]


== Основные этапы разработки программного обеспечения

* *Анализ требований*
   - Сбор и документирование требований от заказчика
   - Формирование технического задания

* *Проектирование архитектуры*
   - Создание схем взаимодействия компонентов
   - Выбор технологий и инструментов

* *Разработка*
   - Непосредственное написание кода
   - Интеграция модулей

* *Тестирование*
   - Ручное и автоматизированное тестирование
   - Отладка и исправление ошибок

== Распределение задач по уровням квалификации

*Senior-разработчики*

* Проектируют архитектуру системы
* Оптимизируют критические участки кода
* Решают сложные технические проблемы
* Проводят код-ревью

*Middle-разработчики*

- Реализуют сложные бизнес-логические модули
- Исправляют архитектурные недочеты
- Помогают junior-разработчикам

*Junior-разработчики*

- Пишут простой функциональный код 
- Реализуют типовые фичи по готовым ТЗ
- Исправляют простые баги

== Процесс компиляции, основные этапы 

1. *Препроцессинг* (этап подготовки)
   - Компилятор обрабатывает все #include и #define
   - Раскрывает макросы и подключает заголовочные файлы
   - На выходе - "очищенный" код без директив препроцессора

2. *Компиляция* (перевод на язык железа)
   - C/C++ код превращается в ассемблерные инструкции
   - Оптимизация кода (если включена)
   - Создаются объектные файлы (.o)

3. *Линковка* (сборка пазла)
   - Компоновщик (линкер) собирает все .o файлы в один
   - Распределяет код по адресам памяти (FLASH/RAM)
   - Использует специальный *линкерный скрипт* для STM32
   

== Особенности для STM32

*В отличие от ПК*

- Адреса памяти жестко заданы 

- Нет операционной системы 
- Исполняемый файл идет прямиком в FLASH-память МК

*Что происходит внутри*:

- Код из main.c превращается в машинные инструкции 
- Переменные попадают в RAM или FLASH 
- Функции получают конкретные адреса во FLASH

== Как запускается функция main()
*Сброс процессора*

   - При подаче питания или ресете
   - Процессор начинает выполнение с адреса 0x08000000
   - Там находится таблица векторов прерываний

*Инициализация переменных*:

   - Настройка тактирования 
   - Подготовка FLASH-памяти (ожидание, ускорение доступа)
   - Базовая настройка RAM
   - Копирование инициализированных переменных из FLASH в RAM
   - Например: `int x = 5;` сначала лежит во FLASH, потом в RAM
   - Обнуление неинициализированных переменных 

*Вызов конструкторов (для C++)*

   - Если проект на C++, вызываются конструкторы глобальных объектов
   - В чистом С этот этап пропускается

*Переход в main()*

   - После всей подготовки вызывается  функция main()
   - Теперь можно работать

== Почему в следующем коде получается 12, а не 13?
[source,cpp]
----
#include <iostream>

int Increment(int value)
{
    static int result = value; // <1>
    result++;
    return result;
}

int main()
{
    auto result = Increment(10);
    std::cout << "result == " << result << std::endl; // 11

    result = Increment(12);
    std::cout << "result == " << result << std::endl; // 12
}
----

Код работает так из-за *статической переменной* `result`:

1. При *первом вызове* `Increment(10)`:
   - Создается статическая переменная `result = 10` (инициализируется один раз)
   - Увеличиваем до 11 → возвращаем 11

2. При *втором вызове* `Increment(12)`:
   - Переменная `result` УЖЕ существует (помнит значение 11)
   - Строка `static int result = value` *игнорируется* (она работает только при первом вызове)
   - Берем текущее значение (11), увеличиваем до 12 → возвращаем 12
  
static-переменные:

- Создаются один раз при первом вызове
- Сохраняют значение между вызовами
- Не переинициализируются при следующих вызовах

== Выводы
=== Основные этапы разработки ПО
1. Низкоквалифицированные инженеры часто пишут код, потому что:
   - Это самый трудоемкий этап
   - Требует меньше архитектурных решений
   - Легче автоматизировать проверку кода

=== Компиляция 
Процесс включает 4 этапа:

* препроцессинг
* компиляция
* ассемблирование
* линковка

=== Запуск main()
- Контроллер перед main() выполняет:
  * Аппаратную инициализацию
  * Настройку памяти
  * Инициализацию переменных

=== Поведение static-переменных
- Инициализируются только один раз (при первом вызове)
- Сохраняют значение между вызовами функции
- Последующие инициализации игнорируются
