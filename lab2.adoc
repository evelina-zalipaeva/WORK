:diagram-use-plantuml:
:author: Залипаева Эвелина КЭ-201
:icon: front
:secttrue: true
:toc: left
:toclevels: 2
:secttruelevels: 2
:sectnums: |,all|
:stylesheet: custom.css
:stylesdir: ./styles
:imagesdir: pic
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица

include::test.adoc[]

== Основные типы данных
* **Примитивные типы**:
  - Целочисленные: `int`, `char`, `short`, `long`
  - С плавающей точкой: `float`, `double`
  - Логический: `bool`
* **Составные типы**:
  - Массивы, структуры, классы
* **Специальные**:
  - Указатели, ссылки

== Как вычисляется размер?
* Используйте `sizeof(тип)` или `sizeof переменная`
* Например: `sizeof(int)` обычно 4 байта

== Преобразования типов

=== Неявное (автоматическое)

Компилятор делает сам:

[source,cpp]
----
int a = 5;
double b = a; // автоматически в double
----

=== Явное (ручное)
Программист указывает явно
[source,cpp]
----
double x = 5.7;

int z = static_cast<int>(x); 
----

==  Когда используется static_cast, когда используется reinterpret_cast?

===  static_cast
*Для безопасных преобразований с проверкой на этапе компиляции*

[source,cpp]
----
float f = 3.14;
int i = static_cast<int>(f); 
----
Когда использовать:

- Преобразования между числовыми типами (int → float, double → int)
- Преобразования в/из void* (с проверкой типа)
- Вниз по иерархии классов (при условии, что типы связаны наследованием)

=== reinterpret_cast
Для низкоуровневых опасных преобразований

[source,cpp]
----
int* p = reinterpret_cast<int*>(0xFF00); // Адрес в указатель
----

Когда использовать:

Преобразование указателей в числа и обратно

Преобразование между несвязанными типами указателей

Работа с аппаратными регистрами

== Почему преобразования - это плохо?

* Потеря точности (double → int)
* Неожиданное поведение
* Проблемы переносимости
* Сложнее читать код

== Что такое указатель?
* Это переменная, которая хранит *адрес* другой переменной
* Объявление: `тип* имя_указателя;`
* Пример:

[source,cpp]
----
int x = 10;
int* ptr = &x;  // ptr хранит адрес x
----
== Основные операции с указателями
&  взять адрес переменной

* разыменование (доступ к значению по адресу)

+, -  арифметика указателей (сдвиг по массиву)

++, - -  инкремент/декремент

==, !=  сравнение указателей

== Почему нельзя вычитать разные указатели?

* Арифметика указателей работает только внутри одного массива

* Разные объекты могут находиться в разных местах памяти

* Результат был бы бессмысленным:

[source,cpp]
----
int a = 1, b = 2;
int* p1 = &a;
int* p2 = &b;
// int diff = p1 - p2;  // Неопределённое поведение
----

== Как установить бит, как сбросить бит, как переключить бит

* Установить бит (OR):
[source,cpp]
----
value |= (1 << bit_position);
----
* Сбросить бит (AND + NOT):
[source,cpp]
----
value &= ~(1 << bit_position);
----
* Переключить бит (XOR):
[source,cpp]
----
value ^= (1 << bit_position);
----

== Операции унарный + и унарный -
=== Унарный плюс (+)
* Просто возвращает значение операнда *без изменений*
* Пример:
[source,cpp]
----
int x = 5;
int y = +x;  // y = 5
----
==== Зачем нужен?

* Для симметрии с унарным минусом

* Может перегружаться для классов

* Иногда используется для явного указания знака

== Унарный минус (-)

Меняет знак числа на противоположный
Пример:

[source,cpp]
----
int a = 7;
int b = -a;  // b = -7
----

Работает с любыми числовыми типами

Для беззнаковых типов может дать неожиданный результат

== Почему если прибавить к  числу типа float  равное 17 000 000  единицу, то получится тоже самое число?

=== Формат числа float (IEEE 754)
* Состоит из 3 частей:
  1. Знак (1 бит)
  2. Экспонента (8 бит)
  3. Мантисса (23 бита)

* Общий вид: (-1)^знак × 1.мантисса × 2^(экспонента-127)

=== Детали для числа 17'000'000

 Двоичное представление:
[source,cpp]
----
   - 17'000'000 = 1.00000001101000100101110 × 2²⁴
   - Экспонента: 24 + 127 = 151 (10010111 в двоичном)
----
В памяти:
[source,cpp]
----
[0][10010111][00000001101000100101110]
(знак+) (экспонента) (мантисса)
----

=== Почему +1 не работает
[source,cpp]
----
 Число 1.0 представляется как:
- 1.0 × 2⁰
- Экспонента: 0 + 127 = 127 (01111111)
----
[source,cpp]
----
 При сложении:
- Разница экспонент: 24 - 0 = 24
- Мантисса 1.0 сдвигается вправо на 24 бита:
  ```
  0.000000000000000000000001
  ```
- После нормализации получаем:
  ```
  1.00000001101000100101110 (исходное)
  + 0.000000000000000000000001 (единица)
  = 1.00000001101000100101110 (результат)
  ```
----
Итог:

- Добавляемое значение меньше единицы младшего разряда 
- Происходит потеря значимости 

==  Пояснить почему 7!=7 в этом примере 
[source,cpp]
----
#include <iostream>

// Type your code here, or load an example.
float GetMagicSeven(float num) {
    
    return 7.7f / 1.1f;
}


int main()
{
    const float Seven = 7.0f;
    float magicSeven = GetMagicSeven(Seven); 
    if (magicSeven == Seven)
    {
        std::cout << "7f == 7f" << std::endl;
    }
    else
    {
        std::cout << "7f != 7f" << std::endl;
        std::cout << magicSeven << std::endl;
        std::cout << Seven << std::endl;
        
    }

}
----


<1> *Основная причина*:  
При операции `7.7f / 1.1f` происходит:
- Вычисления с числами с плавающей точкой имеют ограниченную точность
- Результат НЕ равен ровно 7.0 из-за двоичного представления

<2> *Почему сравнение не работает*:  
Числа с плавающей точкой нельзя сравнивать через `==`:
- `magicSeven` может быть например 6.99999905
- `Seven` = ровно 7.00000000

<3> *Что выведет программа*:
[source,cpp]
----
7f != 7f
6.99999905
7.00000000
----